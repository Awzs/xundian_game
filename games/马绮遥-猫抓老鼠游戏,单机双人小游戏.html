<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫抓老鼠游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        dark: '#1F2937',
                    },
                    fontFamily: {
                        game: ['Arial', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .game-shadow {
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            }
            .text-shadow {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            }
            .animate-pulse-slow {
                animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen font-game flex flex-col items-center justify-center p-4">
<!-- 返回主页按钮 -->
<div id="homeNavigation" style="position: fixed; top: 20px; left: 20px; z-index: 9999;">
    <a href="../index.html" 
       style="display: inline-flex; align-items: center; gap: 8px; 
              background: linear-gradient(135deg, #FF6B6B, #4ECDC4); 
              color: white; padding: 12px 20px; border-radius: 25px; 
              text-decoration: none; font-family: 'Microsoft YaHei', sans-serif; 
              font-weight: bold; font-size: 14px; 
              box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);"
       onmouseover="this.style.transform='translateY(-2px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.3)';"
       onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.2)';">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        返回星球工坊
    </a>
</div>

    <div class="w-full max-w-4xl">
        <!-- 游戏标题 -->
        <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold text-primary text-center mb-6 text-shadow">
            <i class="fa fa-paw mr-2"></i>猫抓老鼠
        </h1>

        <!-- 游戏状态面板 -->
        <div class="grid grid-cols-3 gap-4 mb-4 text-center">
            <div class="bg-white/80 backdrop-blur-sm rounded-lg p-3 shadow-md">
                <p class="text-sm text-gray-600">玩家1 (猫)</p>
                <div class="flex items-center justify-center mt-1">
                    <i class="fa fa-mouse-pointer text-primary text-xl mr-2"></i>
                    <span id="cat-score" class="text-lg font-bold text-primary">0</span>
                </div>
            </div>
            <div class="bg-white/80 backdrop-blur-sm rounded-lg p-3 shadow-md">
                <p class="text-sm text-gray-600">时间</p>
                <div class="flex items-center justify-center mt-1">
                    <i class="fa fa-clock-o text-warning text-xl mr-2"></i>
                    <span id="time-left" class="text-lg font-bold text-warning">60</span>
                </div>
            </div>
            <div class="bg-white/80 backdrop-blur-sm rounded-lg p-3 shadow-md">
                <p class="text-sm text-gray-600">玩家2 (老鼠)</p>
                <div class="flex items-center justify-center mt-1">
                    <i class="fa fa-bolt text-secondary text-xl mr-2"></i>
                    <span id="mouse-score" class="text-lg font-bold text-secondary">0</span>
                </div>
            </div>
        </div>

        <!-- 游戏说明 -->
        <div class="bg-white/80 backdrop-blur-sm rounded-lg p-4 mb-4 shadow-md">
            <div class="flex flex-col md:flex-row justify-between gap-4">
                <div class="flex-1">
                    <h3 class="font-bold text-dark mb-1">猫 (WASD 移动)</h3>
                    <div class="flex items-center space-x-2">
                        <span class="inline-block w-6 h-6 bg-primary rounded-full"></span>
                        <div>
                            <div class="flex">
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">W</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded">↑</span>
                            </div>
                            <div class="flex mt-1">
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">A</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">S</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded">D</span>
                            </div>
                            <div class="flex mt-1">
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded">←</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">↓</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded">→</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex-1">
                    <h3 class="font-bold text-dark mb-1">老鼠 (方向键移动)</h3>
                    <div class="flex items-center space-x-2">
                        <span class="inline-block w-6 h-6 bg-secondary rounded-full"></span>
                        <div>
                            <div class="flex">
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">↑</span>
                            </div>
                            <div class="flex mt-1">
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">←</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded mr-1">↓</span>
                                <span class="w-6 h-6 flex items-center justify-center bg-gray-200 rounded">→</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 游戏容器 -->
        <div class="relative bg-white rounded-lg overflow-hidden game-shadow">
            <canvas id="gameCanvas" class="w-full h-auto"></canvas>
            
            <!-- 游戏控制按钮 -->
            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-3">
                <button id="startBtn" class="px-4 py-2 bg-primary hover:bg-primary/90 text-white rounded-lg shadow-md transition-all flex items-center">
                    <i class="fa fa-play mr-2"></i>开始游戏
                </button>
                <button id="pauseBtn" class="px-4 py-2 bg-warning hover:bg-warning/90 text-white rounded-lg shadow-md transition-all flex items-center hidden">
                    <i class="fa fa-pause mr-2"></i>暂停
                </button>
                <button id="restartBtn" class="px-4 py-2 bg-danger hover:bg-danger/90 text-white rounded-lg shadow-md transition-all flex items-center">
                    <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
            </div>
        </div>

        <!-- 游戏结果模态框 -->
        <div id="resultModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl transform transition-all">
                <h2 id="resultTitle" class="text-2xl font-bold text-center mb-4"></h2>
                <p id="resultMessage" class="text-center mb-6"></p>
                <div class="flex justify-center">
                    <button id="playAgainBtn" class="px-6 py-3 bg-primary hover:bg-primary/90 text-white rounded-lg shadow-md transition-all">
                        再玩一次
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 游戏初始化
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const catScoreEl = document.getElementById('cat-score');
            const mouseScoreEl = document.getElementById('mouse-score');
            const timeLeftEl = document.getElementById('time-left');
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const restartBtn = document.getElementById('restartBtn');
            const resultModal = document.getElementById('resultModal');
            const resultTitle = document.getElementById('resultTitle');
            const resultMessage = document.getElementById('resultMessage');
            const playAgainBtn = document.getElementById('playAgainBtn');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                // 设置canvas尺寸为容器的宽高，同时保持16:9的比例
                const container = canvas.parentElement;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const gameRatio = 16/9;
                let newWidth, newHeight;
                
                if (containerWidth / containerHeight > gameRatio) {
                    newHeight = containerHeight;
                    newWidth = newHeight * gameRatio;
                } else {
                    newWidth = containerWidth;
                    newHeight = newWidth / gameRatio;
                }
                
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // 如果游戏正在进行，重新绘制
                if (gameStarted) {
                    drawGame();
                }
            }
            
            // 监听窗口大小变化，调整Canvas尺寸
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // 游戏状态
            let gameStarted = false;
            let gamePaused = false;
            let gameOver = false;
            let gameLoop;
            let countdown;
            let timeLeft = 60; // 游戏时长（秒）
            let score = {
                cat: 0,
                mouse: 0
            };
            
            // 游戏配置
            const config = {
                catSpeed: 5,
                mouseSpeed: 6,
                obstacleCount: 10,
                foodCount: 5
            };
            
            // 游戏对象
            const cat = {
                x: 100,
                y: 100,
                radius: 20,
                color: '#4F46E5',
                speed: config.catSpeed,
                dx: 0,
                dy: 0,
                keys: {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                }
            };
            
            const mouse = {
                x: 300,
                y: 300,
                radius: 18,
                color: '#10B981',
                speed: config.mouseSpeed,
                dx: 0,
                dy: 0,
                keys: {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                }
            };
            
            // 障碍物
            let obstacles = [];
            
            // 食物
            let foods = [];
            
            // 初始化障碍物
            function initObstacles() {
                obstacles = [];
                for (let i = 0; i < config.obstacleCount; i++) {
                    let obstacle;
                    let validPosition = false;
                    
                    // 确保障碍物不会出现在玩家位置
                    while (!validPosition) {
                        obstacle = {
                            x: 50 + Math.random() * (canvas.width - 100),
                            y: 50 + Math.random() * (canvas.height - 100),
                            width: 40 + Math.random() * 60,
                            height: 40 + Math.random() * 60,
                            color: '#9CA3AF'
                        };
                        
                        // 检查障碍物是否与玩家重叠
                        const catDist = Math.hypot(obstacle.x - cat.x, obstacle.y - cat.y);
                        const mouseDist = Math.hypot(obstacle.x - mouse.x, obstacle.y - mouse.y);
                        
                        if (catDist > (obstacle.width/2 + cat.radius + 30) && 
                            mouseDist > (obstacle.width/2 + mouse.radius + 30)) {
                            validPosition = true;
                        }
                    }
                    
                    obstacles.push(obstacle);
                }
            }
            
            // 初始化食物
            function initFoods() {
                foods = [];
                for (let i = 0; i < config.foodCount; i++) {
                    let food;
                    let validPosition = false;
                    
                    // 确保食物不会出现在玩家或障碍物位置
                    while (!validPosition) {
                        food = {
                            x: 50 + Math.random() * (canvas.width - 100),
                            y: 50 + Math.random() * (canvas.height - 100),
                            radius: 10,
                            color: '#F59E0B'
                        };
                        
                        // 检查食物是否与玩家或障碍物重叠
                        let overlap = false;
                        
                        // 与玩家重叠
                        const catDist = Math.hypot(food.x - cat.x, food.y - cat.y);
                        const mouseDist = Math.hypot(food.x - mouse.x, food.y - mouse.y);
                        
                        if (catDist < (food.radius + cat.radius + 20) || 
                            mouseDist < (food.radius + mouse.radius + 20)) {
                            overlap = true;
                        }
                        
                        // 与障碍物重叠
                        for (const obstacle of obstacles) {
                            const dist = Math.hypot(food.x - obstacle.x, food.y - obstacle.y);
                            if (dist < (food.radius + Math.max(obstacle.width, obstacle.height)/2 + 10)) {
                                overlap = true;
                                break;
                            }
                        }
                        
                        if (!overlap) {
                            validPosition = true;
                        }
                    }
                    
                    foods.push(food);
                }
            }
            
            // 绘制游戏
            function drawGame() {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制背景网格
                drawGrid();
                
                // 绘制障碍物
                for (const obstacle of obstacles) {
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, obstacle.width, obstacle.height);
                    
                    // 绘制边框
                    ctx.strokeStyle = '#6B7280';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, obstacle.width, obstacle.height);
                }
                
                // 绘制食物
                for (const food of foods) {
                    ctx.fillStyle = food.color;
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制高光
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(food.x - 3, food.y - 3, food.radius/3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 绘制猫
                ctx.fillStyle = cat.color;
                ctx.beginPath();
                ctx.arc(cat.x, cat.y, cat.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制猫头方向
                const catEyeAngle = Math.atan2(cat.dy, cat.dx) || 0;
                const eyeDistance = cat.radius * 0.6;
                const eyeSize = cat.radius * 0.2;
                
                // 绘制猫的眼睛
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(
                    cat.x + Math.cos(catEyeAngle - Math.PI/4) * eyeDistance, 
                    cat.y + Math.sin(catEyeAngle - Math.PI/4) * eyeDistance, 
                    eyeSize, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.beginPath();
                ctx.arc(
                    cat.x + Math.cos(catEyeAngle + Math.PI/4) * eyeDistance, 
                    cat.y + Math.sin(catEyeAngle + Math.PI/4) * eyeDistance, 
                    eyeSize, 0, Math.PI * 2
                );
                ctx.fill();
                
                // 绘制猫的瞳孔
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(
                    cat.x + Math.cos(catEyeAngle - Math.PI/4) * eyeDistance, 
                    cat.y + Math.sin(catEyeAngle - Math.PI/4) * eyeDistance, 
                    eyeSize/2, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.beginPath();
                ctx.arc(
                    cat.x + Math.cos(catEyeAngle + Math.PI/4) * eyeDistance, 
                    cat.y + Math.sin(catEyeAngle + Math.PI/4) * eyeDistance, 
                    eyeSize/2, 0, Math.PI * 2
                );
                ctx.fill();
                
                // 绘制猫的耳朵
                ctx.fillStyle = cat.color;
                const earSize = cat.radius * 0.5;
                ctx.beginPath();
                ctx.moveTo(
                    cat.x + Math.cos(catEyeAngle - Math.PI/2) * cat.radius, 
                    cat.y + Math.sin(catEyeAngle - Math.PI/2) * cat.radius
                );
                ctx.lineTo(
                    cat.x + Math.cos(catEyeAngle - 2*Math.PI/3) * (cat.radius + earSize), 
                    cat.y + Math.sin(catEyeAngle - 2*Math.PI/3) * (cat.radius + earSize)
                );
                ctx.lineTo(
                    cat.x + Math.cos(catEyeAngle - Math.PI/3) * (cat.radius + earSize), 
                    cat.y + Math.sin(catEyeAngle - Math.PI/3) * (cat.radius + earSize)
                );
                ctx.closePath();
                ctx.fill();
                
                // 绘制老鼠
                ctx.fillStyle = mouse.color;
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, mouse.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制老鼠头方向
                const mouseEyeAngle = Math.atan2(mouse.dy, mouse.dx) || 0;
                
                // 绘制老鼠的眼睛
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(
                    mouse.x + Math.cos(mouseEyeAngle - Math.PI/4) * eyeDistance * 0.8, 
                    mouse.y + Math.sin(mouseEyeAngle - Math.PI/4) * eyeDistance * 0.8, 
                    eyeSize * 0.8, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.beginPath();
                ctx.arc(
                    mouse.x + Math.cos(mouseEyeAngle + Math.PI/4) * eyeDistance * 0.8, 
                    mouse.y + Math.sin(mouseEyeAngle + Math.PI/4) * eyeDistance * 0.8, 
                    eyeSize * 0.8, 0, Math.PI * 2
                );
                ctx.fill();
                
                // 绘制老鼠的瞳孔
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(
                    mouse.x + Math.cos(mouseEyeAngle - Math.PI/4) * eyeDistance * 0.8, 
                    mouse.y + Math.sin(mouseEyeAngle - Math.PI/4) * eyeDistance * 0.8, 
                    eyeSize/2 * 0.8, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.beginPath();
                ctx.arc(
                    mouse.x + Math.cos(mouseEyeAngle + Math.PI/4) * eyeDistance * 0.8, 
                    mouse.y + Math.sin(mouseEyeAngle + Math.PI/4) * eyeDistance * 0.8, 
                    eyeSize/2 * 0.8, 0, Math.PI * 2
                );
                ctx.fill();
                
                // 绘制老鼠的耳朵
                ctx.fillStyle = mouse.color;
                const mouseEarSize = mouse.radius * 0.6;
                ctx.beginPath();
                ctx.moveTo(
                    mouse.x + Math.cos(mouseEyeAngle - Math.PI/2) * mouse.radius, 
                    mouse.y + Math.sin(mouseEyeAngle - Math.PI/2) * mouse.radius
                );
                ctx.lineTo(
                    mouse.x + Math.cos(mouseEyeAngle - 2*Math.PI/3) * (mouse.radius + mouseEarSize), 
                    mouse.y + Math.sin(mouseEyeAngle - 2*Math.PI/3) * (mouse.radius + mouseEarSize)
                );
                ctx.lineTo(
                    mouse.x + Math.cos(mouseEyeAngle - Math.PI/3) * (mouse.radius + mouseEarSize), 
                    mouse.y + Math.sin(mouseEyeAngle - Math.PI/3) * (mouse.radius + mouseEarSize)
                );
                ctx.closePath();
                ctx.fill();
                
                // 绘制老鼠的尾巴
                const tailLength = mouse.radius * 1.5;
                const tailPoints = 10;
                ctx.strokeStyle = mouse.color;
                ctx.lineWidth = mouse.radius * 0.3;
                ctx.beginPath();
                
                for (let i = 0; i <= tailPoints; i++) {
                    const t = i / tailPoints;
                    const angle = mouseEyeAngle + Math.PI + Math.sin(t * Math.PI * 2) * 0.3;
                    const distance = tailLength * t;
                    const x = mouse.x + Math.cos(angle) * distance;
                    const y = mouse.y + Math.sin(angle) * distance;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // 如果游戏暂停，显示暂停消息
                if (gamePaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('游戏暂停', canvas.width/2, canvas.height/2);
                    ctx.font = '16px Arial';
                    ctx.fillText('按空格键继续', canvas.width/2, canvas.height/2 + 30);
                }
                
                // 如果游戏结束，显示结束消息
                if (gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(canvas.width/2 - 200, canvas.height/2 - 75, 400, 150);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '28px Arial';
                    ctx.textAlign = 'center';
                    
                    if (score.cat > score.mouse) {
                        ctx.fillText('猫获胜！', canvas.width/2, canvas.height/2 - 10);
                    } else if (score.mouse > score.cat) {
                        ctx.fillText('老鼠获胜！', canvas.width/2, canvas.height/2 - 10);
                    } else {
                        ctx.fillText('平局！', canvas.width/2, canvas.height/2 - 10);
                    }
                    
                    ctx.font = '18px Arial';
                    ctx.fillText(`得分: 猫 ${score.cat} - 老鼠 ${score.mouse}`, canvas.width/2, canvas.height/2 + 25);
                    ctx.fillText('按R键重新开始', canvas.width/2, canvas.height/2 + 55);
                }
            }
            
            // 绘制背景网格
            function drawGrid() {
                const gridSize = 40;
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.lineWidth = 1;
                
                // 绘制垂直线
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 绘制水平线
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            // 更新游戏状态
            function updateGame() {
                if (gamePaused || gameOver) return;
                
                // 更新猫的位置
                if (cat.keys.up) cat.dy = -cat.speed;
                else if (cat.keys.down) cat.dy = cat.speed;
                else cat.dy = 0;
                
                if (cat.keys.left) cat.dx = -cat.speed;
                else if (cat.keys.right) cat.dx = cat.speed;
                else cat.dx = 0;
                
                // 更新老鼠的位置
                if (mouse.keys.up) mouse.dy = -mouse.speed;
                else if (mouse.keys.down) mouse.dy = mouse.speed;
                else mouse.dy = 0;
                
                if (mouse.keys.left) mouse.dx = -mouse.speed;
                else if (mouse.keys.right) mouse.dx = mouse.speed;
                else mouse.dx = 0;
                
                // 移动猫
                let newCatX = cat.x + cat.dx;
                let newCatY = cat.y + cat.dy;
                
                // 检查猫是否碰到边界
                if (newCatX - cat.radius < 0) newCatX = cat.radius;
                if (newCatX + cat.radius > canvas.width) newCatX = canvas.width - cat.radius;
                if (newCatY - cat.radius < 0) newCatY = cat.radius;
                if (newCatY + cat.radius > canvas.height) newCatY = canvas.height - cat.radius;
                
                // 检查猫是否碰到障碍物
                let collision = false;
                for (const obstacle of obstacles) {
                    const closestX = Math.max(obstacle.x - obstacle.width/2, Math.min(newCatX, obstacle.x + obstacle.width/2));
                    const closestY = Math.max(obstacle.y - obstacle.height/2, Math.min(newCatY, obstacle.y + obstacle.height/2));
                    
                    const distance = Math.hypot(newCatX - closestX, newCatY - closestY);
                    
                    if (distance < cat.radius) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    cat.x = newCatX;
                    cat.y = newCatY;
                }
                
                // 移动老鼠
                let newMouseX = mouse.x + mouse.dx;
                let newMouseY = mouse.y + mouse.dy;
                
                // 检查老鼠是否碰到边界
                if (newMouseX - mouse.radius < 0) newMouseX = mouse.radius;
                if (newMouseX + mouse.radius > canvas.width) newMouseX = canvas.width - mouse.radius;
                if (newMouseY - mouse.radius < 0) newMouseY = mouse.radius;
                if (newMouseY + mouse.radius > canvas.height) newMouseY = canvas.height - mouse.radius;
                
                // 检查老鼠是否碰到障碍物
                collision = false;
                for (const obstacle of obstacles) {
                    const closestX = Math.max(obstacle.x - obstacle.width/2, Math.min(newMouseX, obstacle.x + obstacle.width/2));
                    const closestY = Math.max(obstacle.y - obstacle.height/2, Math.min(newMouseY, obstacle.y + obstacle.height/2));
                    
                    const distance = Math.hypot(newMouseX - closestX, newMouseY - closestY);
                    
                    if (distance < mouse.radius) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    mouse.x = newMouseX;
                    mouse.y = newMouseY;
                }
                
                // 检查猫是否抓到老鼠
                const catMouseDistance = Math.hypot(cat.x - mouse.x, cat.y - mouse.y);
                if (catMouseDistance < cat.radius + mouse.radius) {
                    score.cat++;
                    catScoreEl.textContent = score.cat;
                    resetPositions();
                    showMessage('猫抓到了老鼠！', '#4F46E5');
                }
                
                // 检查老鼠是否吃到食物
                for (let i = 0; i < foods.length; i++) {
                    const food = foods[i];
                    const mouseFoodDistance = Math.hypot(mouse.x - food.x, mouse.y - food.y);
                    
                    if (mouseFoodDistance < mouse.radius + food.radius) {
                        score.mouse++;
                        mouseScoreEl.textContent = score.mouse;
                        foods.splice(i, 1);
                        
                        // 生成新食物
                        setTimeout(() => {
                            if (foods.length < config.foodCount && !gameOver) {
                                initFoods();
                            }
                        }, 2000);
                        
                        showMessage('老鼠吃到了食物！', '#10B981');
                        break;
                    }
                }
                
                // 绘制游戏
                drawGame();
            }
            
            // 重置玩家位置
            function resetPositions() {
                cat.x = 100 + Math.random() * 100;
                cat.y = 100 + Math.random() * 100;
                cat.dx = 0;
                cat.dy = 0;
                
                mouse.x = canvas.width - 100 - Math.random() * 100;
                mouse.y = canvas.height - 100 - Math.random() * 100;
                mouse.dx = 0;
                mouse.dy = 0;
            }
            
            // 显示临时消息
            function showMessage(text, color) {
                const messageEl = document.createElement('div');
                messageEl.className = 'fixed top-1/4 left-1/2 transform -translate-x-1/2 bg-white/90 text-center px-6 py-3 rounded-lg shadow-lg font-bold text-xl';
                messageEl.style.color = color;
                messageEl.textContent = text;
                document.body.appendChild(messageEl);
                
                setTimeout(() => {
                    messageEl.classList.add('opacity-0', 'transition-opacity', 'duration-500');
                    setTimeout(() => {
                        document.body.removeChild(messageEl);
                    }, 500);
                }, 1500);
            }
            
            // 开始游戏
            function startGame() {
                if (gameStarted) return;
                
                gameStarted = true;
                gamePaused = false;
                gameOver = false;
                
                // 重置分数和时间
                score = {
                    cat: 0,
                    mouse: 0
                };
                timeLeft = 60;
                
                catScoreEl.textContent = score.cat;
                mouseScoreEl.textContent = score.mouse;
                timeLeftEl.textContent = timeLeft;
                
                // 初始化障碍物和食物
                initObstacles();
                initFoods();
                
                // 重置玩家位置
                resetPositions();
                
                // 开始游戏循环
                gameLoop = requestAnimationFrame(gameCycle);
                
                // 开始倒计时
                countdown = setInterval(() => {
                    if (gamePaused || gameOver) return;
                    
                    timeLeft--;
                    timeLeftEl.textContent = timeLeft;
                    
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }, 1000);
                
                // 更新按钮状态
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
            }
            
            // 暂停游戏
            function pauseGame() {
                if (!gameStarted || gameOver) return;
                
                gamePaused = !gamePaused;
                
                if (gamePaused) {
                    pauseBtn.innerHTML = '<i class="fa fa-play mr-2"></i>继续';
                } else {
                    pauseBtn.innerHTML = '<i class="fa fa-pause mr-2"></i>暂停';
                    gameLoop = requestAnimationFrame(gameCycle);
                }
            }
            
            // 结束游戏
            function endGame() {
                gameOver = true;
                cancelAnimationFrame(gameLoop);
                clearInterval(countdown);
                
                // 更新按钮状态
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
                
                // 显示结果模态框
                if (score.cat > score.mouse) {
                    resultTitle.textContent = '猫获胜！';
                    resultMessage.textContent = `猫抓到了老鼠 ${score.cat} 次，而老鼠只吃到了 ${score.mouse} 个食物。`;
                } else if (score.mouse > score.cat) {
                    resultTitle.textContent = '老鼠获胜！';
                    resultMessage.textContent = `老鼠成功吃到了 ${score.mouse} 个食物，而只被猫抓到了 ${score.cat} 次。`;
                } else {
                    resultTitle.textContent = '平局！';
                    resultMessage.textContent = `双方打成平手，猫抓到了老鼠 ${score.cat} 次，老鼠吃到了 ${score.mouse} 个食物。`;
                }
                
                resultModal.classList.remove('hidden');
            }
            
            // 重新开始游戏
            function restartGame() {
                if (gameLoop) cancelAnimationFrame(gameLoop);
                if (countdown) clearInterval(countdown);
                
                gameStarted = false;
                gamePaused = false;
                gameOver = false;
                
                // 更新按钮状态
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
                
                // 绘制初始状态
                drawGame();
            }
            
            // 游戏循环
            function gameCycle() {
                updateGame();
                if (!gamePaused && !gameOver) {
                    gameLoop = requestAnimationFrame(gameCycle);
                }
            }
            
            // 键盘事件监听
            document.addEventListener('keydown', (e) => {
                // 猫的控制 (WASD)
                if (e.key === 'w' || e.key === 'W') cat.keys.up = true;
                if (e.key === 's' || e.key === 'S') cat.keys.down = true;
                if (e.key === 'a' || e.key === 'A') cat.keys.left = true;
                if (e.key === 'd' || e.key === 'D') cat.keys.right = true;
                
                // 老鼠的控制 (方向键)
                if (e.key === 'ArrowUp') mouse.keys.up = true;
                if (e.key === 'ArrowDown') mouse.keys.down = true;
                if (e.key === 'ArrowLeft') mouse.keys.left = true;
                if (e.key === 'ArrowRight') mouse.keys.right = true;
                
                // 暂停/继续游戏 (空格键)
                if (e.key === ' ') {
                    e.preventDefault(); // 防止页面滚动
                    if (gameStarted && !gameOver) {
                        pauseGame();
                    }
                }
                
                // 重新开始游戏 (R键)
                if (e.key === 'r' || e.key === 'R') {
                    restartGame();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                // 猫的控制 (WASD)
                if (e.key === 'w' || e.key === 'W') cat.keys.up = false;
                if (e.key === 's' || e.key === 'S') cat.keys.down = false;
                if (e.key === 'a' || e.key === 'A') cat.keys.left = false;
                if (e.key === 'd' || e.key === 'D') cat.keys.right = false;
                
                // 老鼠的控制 (方向键)
                if (e.key === 'ArrowUp') mouse.keys.up = false;
                if (e.key === 'ArrowDown') mouse.keys.down = false;
                if (e.key === 'ArrowLeft') mouse.keys.left = false;
                if (e.key === 'ArrowRight') mouse.keys.right = false;
            });
            
            // 按钮事件监听
            startBtn.addEventListener('click', startGame);
            pauseBtn.addEventListener('click', pauseGame);
            restartBtn.addEventListener('click', restartGame);
            playAgainBtn.addEventListener('click', () => {
                resultModal.classList.add('hidden');
                restartGame();
            });
            
            // 初始绘制
            drawGame();
        });
    </script>

<!-- Author Signature Widget V2 -->
<script id="author-signature-widget-v2">
  (function() {
    function showSignature() {
      var authorNameStr = '*绮遥';

      if (document.getElementById('author-signature-container-v2')) {
        return;
      }

      var container = document.createElement('div');
      container.id = 'author-signature-container-v2';
      container.style.position = 'fixed';
      container.style.top = '50%';
      container.style.left = '50%';
      container.style.transform = 'translate(-50%, -50%) scale(0.7)';
      container.style.padding = '30px 50px';
      container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      container.style.color = 'white';
      container.style.borderRadius = '20px';
      container.style.zIndex = '2147483647';
      container.style.fontFamily = '"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif';
      container.style.fontSize = '10vw';
      container.style.fontWeight = 'bold';
      container.style.textAlign = 'center';
      container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
      container.style.opacity = '0';
      container.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      container.style.whiteSpace = 'nowrap';
      container.style.cursor = 'pointer';

      var textElement = document.createElement('span');
      textElement.textContent = '作者: ' + authorNameStr;

      var hideWidget = function() {
        container.style.transform = 'translate(-50%, -50%) scale(0.7)';
        container.style.opacity = '0';
        setTimeout(function() {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
        }, 500);
      };

      container.onclick = hideWidget;

      container.appendChild(textElement);
      document.body.appendChild(container);

      setTimeout(function() {
        container.style.opacity = '1';
        container.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 50);

      setTimeout(hideWidget, 5000);
    }

    if (document.body) {
        showSignature();
    } else {
        document.addEventListener('DOMContentLoaded', showSignature);
    }
  })();
</script>
</body>
</html>
    