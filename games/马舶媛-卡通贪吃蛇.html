<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>卡通贪吃蛇</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4CAF50',     // 主色调：绿色（蛇身）
                        secondary: '#FF9800',   // 辅助色：橙色（食物）
                        accent: '#2196F3',      // 强调色：蓝色（头部）
                        dark: '#333333',        // 深色文本
                        light: '#F5F5F5',       // 浅色背景
                        panel: '#FFFFFF',       // 面板背景
                        border: '#E0E0E0',      // 边框颜色
                    },
                    fontFamily: {
                        game: ['"Comic Sans MS"', '"Marker Felt"', 'Arial', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            }
            .game-gradient {
                background: linear-gradient(135deg, #f0f9ff 0%, #cbebff 47%, #a1dbff 100%);
            }
            .btn-hover {
                @apply transition-all duration-300 hover:scale-105 hover:shadow-lg active:scale-95;
            }
            .grid-pattern {
                background-image: linear-gradient(#e0e0e0 1px, transparent 1px),
                                linear-gradient(90deg, #e0e0e0 1px, transparent 1px);
                background-size: 20px 20px;
            }
        }
    </style>
    
    <style>
        body {
            overflow-x: hidden;
        }
        
        /* 贪吃蛇游戏元素样式 */
        #game-canvas {
            display: block;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            background-color: rgba(255, 255, 255, 0.8);
        }
        
        /* 游戏控制按钮样式 */
        .control-btn {
            @apply bg-primary text-white rounded-full p-3 shadow-md btn-hover;
        }
        
        .control-btn:active {
            @apply bg-primary/80;
        }
        
        /* 游戏状态面板样式 */
        .game-panel {
            @apply bg-panel rounded-xl shadow-lg p-4 border border-border;
        }
        
        /* 难度选择样式 */
        .difficulty-btn {
            @apply px-4 py-2 rounded-lg btn-hover transition-all duration-300;
        }
        
        .difficulty-btn.active {
            @apply bg-accent text-white;
        }
        
        /* 动画效果 */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        /* 食物闪烁效果 */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .food-blink {
            animation: blink 1s infinite;
        }
        
        /* 游戏结束弹窗动画 */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .modal-animation {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="min-h-screen game-gradient flex flex-col items-center justify-center p-4 font-game text-dark">
<!-- 返回主页按钮 -->
<div id="homeNavigation" style="position: fixed; top: 20px; left: 20px; z-index: 9999;">
    <a href="../index.html" 
       style="display: inline-flex; align-items: center; gap: 8px; 
              background: linear-gradient(135deg, #FF6B6B, #4ECDC4); 
              color: white; padding: 12px 20px; border-radius: 25px; 
              text-decoration: none; font-family: 'Microsoft YaHei', sans-serif; 
              font-weight: bold; font-size: 14px; 
              box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);"
       onmouseover="this.style.transform='translateY(-2px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.3)';"
       onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.2)';">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        返回星球工坊
    </a>
</div>

    <!-- 游戏标题 -->
    <h1 class="text-[clamp(2rem,5vw,3.5rem)] font-bold text-primary text-shadow mb-6 flex items-center">
        <i class="fa fa-gamepad mr-3"></i>卡通贪吃蛇
    </h1>
    
    <!-- 游戏区域 -->
    <div class="max-w-3xl w-full flex flex-col md:flex-row gap-6 items-center md:items-start">
        <!-- 游戏画布 -->
        <div class="relative w-full md:w-2/3">
            <canvas id="game-canvas" class="w-full aspect-square grid-pattern"></canvas>
            
            <!-- 移动端控制按钮 -->
            <div class="md:hidden absolute bottom-4 left-1/2 -translate-x-1/2 grid grid-cols-3 gap-2 w-48">
                <div></div>
                <button id="up-btn" class="control-btn">
                    <i class="fa fa-chevron-up"></i>
                </button>
                <div></div>
                <button id="left-btn" class="control-btn">
                    <i class="fa fa-chevron-left"></i>
                </button>
                <div></div>
                <button id="right-btn" class="control-btn">
                    <i class="fa fa-chevron-right"></i>
                </button>
                <div></div>
                <button id="down-btn" class="control-btn">
                    <i class="fa fa-chevron-down"></i>
                </button>
                <div></div>
            </div>
        </div>
        
        <!-- 游戏控制面板 -->
        <div class="game-panel w-full md:w-1/3 flex flex-col gap-4">
            <!-- 分数显示 -->
            <div class="flex justify-between items-center bg-light rounded-lg p-3">
                <div class="flex items-center">
                    <i class="fa fa-star text-yellow-500 mr-2"></i>
                    <span class="font-bold">分数:</span>
                </div>
                <span id="score" class="text-2xl font-bold text-primary">0</span>
            </div>
            
            <!-- 最高分显示 -->
            <div class="flex justify-between items-center bg-light rounded-lg p-3">
                <div class="flex items-center">
                    <i class="fa fa-trophy text-secondary mr-2"></i>
                    <span class="font-bold">最高分:</span>
                </div>
                <span id="high-score" class="text-xl font-bold text-secondary">0</span>
            </div>
            
            <!-- 游戏控制按钮 -->
            <div class="grid grid-cols-2 gap-3">
                <button id="start-btn" class="bg-primary text-white rounded-lg py-3 px-4 font-bold btn-hover flex items-center justify-center">
                    <i class="fa fa-play mr-2"></i>开始
                </button>
                <button id="pause-btn" class="bg-secondary text-white rounded-lg py-3 px-4 font-bold btn-hover flex items-center justify-center" disabled>
                    <i class="fa fa-pause mr-2"></i>暂停
                </button>
                <button id="restart-btn" class="bg-accent text-white rounded-lg py-3 px-4 font-bold btn-hover flex items-center justify-center">
                    <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
                <button id="sound-btn" class="bg-dark text-white rounded-lg py-3 px-4 font-bold btn-hover flex items-center justify-center">
                    <i class="fa fa-volume-up mr-2"></i>声音
                </button>
            </div>
            
            <!-- 难度选择 -->
            <div>
                <h3 class="font-bold mb-2 text-lg">难度:</h3>
                <div class="flex gap-2">
                    <button class="difficulty-btn active" data-speed="150">简单</button>
                    <button class="difficulty-btn" data-speed="100">中等</button>
                    <button class="difficulty-btn" data-speed="60">困难</button>
                </div>
            </div>
            
            <!-- 游戏说明 -->
            <div class="bg-light rounded-lg p-3 text-sm">
                <h3 class="font-bold mb-2">游戏说明:</h3>
                <ul class="list-disc pl-5 space-y-1">
                    <li>使用方向键或虚拟按钮控制蛇的移动</li>
                    <li>吃到食物增长分数并变长</li>
                    <li>撞到边界或自己的身体游戏结束</li>
                    <li>难度越高蛇移动速度越快</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- 游戏结束弹窗 -->
    <div id="game-over-modal" class="fixed inset-0 flex items-center justify-center bg-black/50 z-50 hidden">
        <div class="bg-white rounded-xl p-8 max-w-md w-full mx-4 modal-animation">
            <div class="text-center">
                <h2 class="text-3xl font-bold text-red-500 mb-2">游戏结束!</h2>
                <p class="text-lg mb-4">你的分数: <span id="final-score" class="font-bold text-primary">0</span></p>
                <p class="text-lg mb-6">最高分: <span id="final-high-score" class="font-bold text-secondary">0</span></p>
                <div class="flex gap-3 justify-center">
                    <button id="play-again-btn" class="bg-primary text-white rounded-lg py-3 px-6 font-bold btn-hover">
                        <i class="fa fa-refresh mr-2"></i>再玩一次
                    </button>
                    <button id="close-modal-btn" class="bg-gray-300 text-dark rounded-lg py-3 px-6 font-bold btn-hover">
                        <i class="fa fa-times mr-2"></i>关闭
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 获取DOM元素
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const restartBtn = document.getElementById('restart-btn');
        const soundBtn = document.getElementById('sound-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreElement = document.getElementById('final-score');
        const finalHighScoreElement = document.getElementById('final-high-score');
        const playAgainBtn = document.getElementById('play-again-btn');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        const mobileBtns = {
            up: document.getElementById('up-btn'),
            down: document.getElementById('down-btn'),
            left: document.getElementById('left-btn'),
            right: document.getElementById('right-btn')
        };
        
        // 游戏配置
        let gameConfig = {
            gridSize: 20,        // 网格大小
            initialSpeed: 150,   // 初始速度（毫秒）
            speed: 150,          // 当前速度
            soundEnabled: true,  // 声音开关
            isRunning: false,    // 游戏是否正在运行
            isPaused: false,     // 游戏是否暂停
            score: 0,            // 当前分数
            highScore: 0,        // 最高分
            direction: 'right',  // 蛇的方向
            nextDirection: 'right', // 下一次移动的方向
            snake: [],           // 蛇的身体位置
            food: {},            // 食物位置
            bonusFood: null,     // 奖励食物位置
            foodTimer: 0,        // 食物计时器
            foodDuration: 100,   // 食物持续时间
            bonusFoodTimer: 0,   // 奖励食物计时器
            bonusFoodDuration: 30, // 奖励食物持续时间
            obstacles: [],       // 障碍物位置
            canvasSize: 0,       // 画布大小
            animationId: null,   // 动画ID
            lastTime: 0,         // 上次更新时间
            deltaTime: 0,        // 时间差
            soundEffects: {      // 音效
                eat: new Audio('data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYAADQAAAA=='),
                gameOver: new Audio('data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYAADQAAAA=='),
                bonus: new Audio('data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYAADQAAAA==')
            }
        };
        
        // 初始化游戏
        function initGame() {
            // 设置画布大小
            const containerWidth = canvas.parentElement.clientWidth;
            canvasSize = Math.min(containerWidth, 600);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            // 计算网格数
            const gridCount = Math.floor(canvasSize / gameConfig.gridSize);
            gameConfig.gridSize = canvasSize / gridCount;
            
            // 重置游戏状态
            gameConfig.score = 0;
            gameConfig.direction = 'right';
            gameConfig.nextDirection = 'right';
            
            // 初始化蛇 (3个方块长)
            const center = Math.floor(gridCount / 2);
            gameConfig.snake = [
                {x: center, y: center},
                {x: center - 1, y: center},
                {x: center - 2, y: center}
            ];
            
            // 生成食物
            generateFood();
            gameConfig.bonusFood = null;
            gameConfig.foodTimer = 0;
            gameConfig.bonusFoodTimer = 0;
            
            // 清空障碍物
            gameConfig.obstacles = [];
            
            // 更新分数显示
            updateScore();
            
            // 绘制游戏
            drawGame();
        }
        
        // 生成食物
        function generateFood() {
            const gridCount = Math.floor(canvasSize / gameConfig.gridSize);
            let newFood;
            
            // 确保食物不会出现在蛇身上或障碍物上
            do {
                newFood = {
                    x: Math.floor(Math.random() * gridCount),
                    y: Math.floor(Math.random() * gridCount)
                };
            } while (isPositionOccupied(newFood.x, newFood.y));
            
            gameConfig.food = newFood;
        }
        
        // 生成奖励食物
        function generateBonusFood() {
            const gridCount = Math.floor(canvasSize / gameConfig.gridSize);
            let newBonusFood;
            
            // 确保奖励食物不会出现在蛇身上、普通食物或障碍物上
            do {
                newBonusFood = {
                    x: Math.floor(Math.random() * gridCount),
                    y: Math.floor(Math.random() * gridCount)
                };
            } while (isPositionOccupied(newBonusFood.x, newBonusFood.y));
            
            gameConfig.bonusFood = newBonusFood;
        }
        
        // 检查位置是否被占用
        function isPositionOccupied(x, y) {
            // 检查蛇身
            for (let segment of gameConfig.snake) {
                if (segment.x === x && segment.y === y) {
                    return true;
                }
            }
            
            // 检查普通食物
            if (gameConfig.food.x === x && gameConfig.food.y === y) {
                return true;
            }
            
            // 检查奖励食物
            if (gameConfig.bonusFood && gameConfig.bonusFood.x === x && gameConfig.bonusFood.y === y) {
                return true;
            }
            
            // 检查障碍物
            for (let obstacle of gameConfig.obstacles) {
                if (obstacle.x === x && obstacle.y === y) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 更新游戏状态
        function updateGame(timestamp) {
            // 计算时间差
            if (!gameConfig.lastTime) {
                gameConfig.lastTime = timestamp;
            }
            gameConfig.deltaTime += timestamp - gameConfig.lastTime;
            gameConfig.lastTime = timestamp;
            
            // 按固定间隔更新游戏状态
            if (gameConfig.deltaTime >= gameConfig.speed) {
                gameConfig.deltaTime = 0;
                
                // 移动蛇
                moveSnake();
                
                // 检查是否吃到食物
                checkFoodCollision();
                
                // 检查是否撞到自己或边界
                if (checkCollision()) {
                    gameOver();
                    return;
                }
                
                // 更新食物计时器
                gameConfig.foodTimer++;
                if (gameConfig.foodTimer >= gameConfig.foodDuration) {
                    generateFood();
                    gameConfig.foodTimer = 0;
                }
                
                // 更新奖励食物计时器
                if (gameConfig.bonusFood) {
                    gameConfig.bonusFoodTimer++;
                    if (gameConfig.bonusFoodTimer >= gameConfig.bonusFoodDuration) {
                        gameConfig.bonusFood = null;
                        gameConfig.bonusFoodTimer = 0;
                    }
                } else if (Math.random() < 0.01 && gameConfig.score > 0) { // 1%的概率生成奖励食物
                    generateBonusFood();
                }
                
                // 每得5分增加一个障碍物
                if (gameConfig.score > 0 && gameConfig.score % 5 === 0 && gameConfig.obstacles.length < gameConfig.score / 5) {
                    addObstacle();
                }
            }
            
            // 绘制游戏
            drawGame();
            
            // 继续游戏循环
            if (gameConfig.isRunning && !gameConfig.isPaused) {
                gameConfig.animationId = requestAnimationFrame(updateGame);
            }
        }
        
        // 移动蛇
        function moveSnake() {
            // 更新方向
            gameConfig.direction = gameConfig.nextDirection;
            
            // 获取蛇头位置
            const head = {x: gameConfig.snake[0].x, y: gameConfig.snake[0].y};
            
            // 根据方向移动蛇头
            switch (gameConfig.direction) {
                case 'up':
                    head.y--;
                    break;
                case 'down':
                    head.y++;
                    break;
                case 'left':
                    head.x--;
                    break;
                case 'right':
                    head.x++;
                    break;
            }
            
            // 将新头部添加到蛇身
            gameConfig.snake.unshift(head);
            
            // 如果没有吃到食物，移除尾部
            if (!gameConfig.ateFood) {
                gameConfig.snake.pop();
            } else {
                gameConfig.ateFood = false;
            }
        }
        
        // 检查食物碰撞
        function checkFoodCollision() {
            const head = gameConfig.snake[0];
            
            // 检查普通食物
            if (head.x === gameConfig.food.x && head.y === gameConfig.food.y) {
                // 增加分数
                gameConfig.score += 10;
                gameConfig.ateFood = true;
                
                // 播放吃食物音效
                if (gameConfig.soundEnabled) {
                    gameConfig.soundEffects.eat.play();
                }
                
                // 更新分数显示
                updateScore();
                
                // 生成新食物
                generateFood();
                
                // 加速
                if (gameConfig.speed > 50) {
                    gameConfig.speed -= 2;
                }
            }
            
            // 检查奖励食物
            if (gameConfig.bonusFood && head.x === gameConfig.bonusFood.x && head.y === gameConfig.bonusFood.y) {
                // 增加额外分数
                gameConfig.score += 50;
                gameConfig.ateFood = true;
                
                // 播放奖励音效
                if (gameConfig.soundEnabled) {
                    gameConfig.soundEffects.bonus.play();
                }
                
                // 更新分数显示
                updateScore();
                
                // 移除奖励食物
                gameConfig.bonusFood = null;
                gameConfig.bonusFoodTimer = 0;
                
                // 加速更多
                if (gameConfig.speed > 40) {
                    gameConfig.speed -= 5;
                }
            }
        }
        
        // 检查碰撞
        function checkCollision() {
            const head = gameConfig.snake[0];
            const gridCount = Math.floor(canvasSize / gameConfig.gridSize);
            
            // 检查是否撞到边界
            if (head.x < 0 || head.x >= gridCount || head.y < 0 || head.y >= gridCount) {
                return true;
            }
            
            // 检查是否撞到自己
            for (let i = 1; i < gameConfig.snake.length; i++) {
                if (head.x === gameConfig.snake[i].x && head.y === gameConfig.snake[i].y) {
                    return true;
                }
            }
            
            // 检查是否撞到障碍物
            for (let obstacle of gameConfig.obstacles) {
                if (head.x === obstacle.x && head.y === obstacle.y) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 添加障碍物
        function addObstacle() {
            const gridCount = Math.floor(canvasSize / gameConfig.gridSize);
            let newObstacle;
            
            // 确保障碍物不会出现在蛇身上、食物或其他障碍物上
            do {
                newObstacle = {
                    x: Math.floor(Math.random() * gridCount),
                    y: Math.floor(Math.random() * gridCount)
                };
            } while (isPositionOccupied(newObstacle.x, newObstacle.y));
            
            gameConfig.obstacles.push(newObstacle);
        }
        
        // 绘制游戏
        function drawGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制障碍物
            ctx.fillStyle = '#607D8B';
            for (let obstacle of gameConfig.obstacles) {
                ctx.beginPath();
                ctx.roundRect(
                    obstacle.x * gameConfig.gridSize,
                    obstacle.y * gameConfig.gridSize,
                    gameConfig.gridSize,
                    gameConfig.gridSize,
                    5
                );
                ctx.fill();
            }
            
            // 绘制蛇
            for (let i = 0; i < gameConfig.snake.length; i++) {
                const segment = gameConfig.snake[i];
                
                // 蛇头使用不同颜色
                if (i === 0) {
                    ctx.fillStyle = '#2196F3'; // 蓝色头部
                    
                    // 绘制眼睛
                    const eyeSize = gameConfig.gridSize / 8;
                    const eyeOffset = gameConfig.gridSize / 3;
                    
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x * gameConfig.gridSize,
                        segment.y * gameConfig.gridSize,
                        gameConfig.gridSize,
                        gameConfig.gridSize,
                        gameConfig.gridSize / 3
                    );
                    ctx.fill();
                    
                    // 根据方向绘制眼睛
                    ctx.fillStyle = 'white';
                    if (gameConfig.direction === 'right') {
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            segment.y * gameConfig.gridSize + eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            segment.y * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (gameConfig.direction === 'left') {
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + eyeOffset,
                            segment.y * gameConfig.gridSize + eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + eyeOffset,
                            segment.y * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (gameConfig.direction === 'up') {
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + eyeOffset,
                            segment.y * gameConfig.gridSize + eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            segment.y * gameConfig.gridSize + eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (gameConfig.direction === 'down') {
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + eyeOffset,
                            segment.y * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(
                            segment.x * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            segment.y * gameConfig.gridSize + gameConfig.gridSize - eyeOffset,
                            eyeSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                } else {
                    // 蛇身体使用渐变色
                    const colorRatio = 1 - i / gameConfig.snake.length;
                    const r = Math.floor(76 * colorRatio);
                    const g = Math.floor(175 * colorRatio);
                    const b = Math.floor(80 * colorRatio);
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x * gameConfig.gridSize,
                        segment.y * gameConfig.gridSize,
                        gameConfig.gridSize,
                        gameConfig.gridSize,
                        gameConfig.gridSize / 4
                    );
                    ctx.fill();
                }
            }
            
            // 绘制普通食物
            ctx.fillStyle = '#FF9800';
            ctx.beginPath();
            ctx.arc(
                gameConfig.food.x * gameConfig.gridSize + gameConfig.gridSize / 2,
                gameConfig.food.y * gameConfig.gridSize + gameConfig.gridSize / 2,
                gameConfig.gridSize / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // 添加食物光泽
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(
                gameConfig.food.x * gameConfig.gridSize + gameConfig.gridSize / 3,
                gameConfig.food.y * gameConfig.gridSize + gameConfig.gridSize / 3,
                gameConfig.gridSize / 5,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // 绘制奖励食物
            if (gameConfig.bonusFood) {
                // 绘制星形
                drawStar(
                    gameConfig.bonusFood.x * gameConfig.gridSize + gameConfig.gridSize / 2,
                    gameConfig.bonusFood.y * gameConfig.gridSize + gameConfig.gridSize / 2,
                    5,
                    gameConfig.gridSize / 2,
                    gameConfig.gridSize / 4,
                    '#FFEB3B'
                );
                
                // 添加闪烁效果
                const blinkFactor = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 235, 59, ${blinkFactor})`;
                drawStar(
                    gameConfig.bonusFood.x * gameConfig.gridSize + gameConfig.gridSize / 2,
                    gameConfig.bonusFood.y * gameConfig.gridSize + gameConfig.gridSize / 2,
                    5,
                    gameConfig.gridSize / 2 * 0.8,
                    gameConfig.gridSize / 4 * 0.8,
                    '#FFEB3B'
                );
            }
            
            // 如果游戏暂停，显示暂停信息
            if (gameConfig.isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${canvasSize / 10}px game`;
                ctx.textAlign = 'center';
                ctx.fillText('游戏暂停', canvas.width / 2, canvas.height / 2);
                ctx.font = `bold ${canvasSize / 20}px game`;
                ctx.fillText('按空格键继续', canvas.width / 2, canvas.height / 2 + canvasSize / 8);
            }
        }
        
        // 绘制星形函数
        function drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(cx + outerRadius, cy);
            
            for (let i = 1; i < spikes * 2; i++) {
                const angle = (i * Math.PI / spikes) - (Math.PI / 2);
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                ctx.lineTo(x, y);
            }
            
            ctx.closePath();
            ctx.fill();
        }
        
        // 更新分数
        function updateScore() {
            scoreElement.textContent = gameConfig.score;
            
            // 更新最高分
            if (gameConfig.score > gameConfig.highScore) {
                gameConfig.highScore = gameConfig.score;
                highScoreElement.textContent = gameConfig.highScore;
                
                // 存储最高分
                localStorage.setItem('snakeHighScore', gameConfig.highScore);
            }
        }
        
        // 开始游戏
        function startGame() {
            if (!gameConfig.isRunning) {
                gameConfig.isRunning = true;
                gameConfig.isPaused = false;
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                
                // 重置游戏状态
                initGame();
                
                // 开始游戏循环
                gameConfig.lastTime = 0;
                gameConfig.deltaTime = 0;
                gameConfig.animationId = requestAnimationFrame(updateGame);
            }
        }
        
        // 暂停游戏
        function pauseGame() {
            if (gameConfig.isRunning && !gameConfig.isPaused) {
                gameConfig.isPaused = true;
                pauseBtn.innerHTML = '<i class="fa fa-play mr-2"></i>继续';
                cancelAnimationFrame(gameConfig.animationId);
            } else if (gameConfig.isRunning && gameConfig.isPaused) {
                gameConfig.isPaused = false;
                pauseBtn.innerHTML = '<i class="fa fa-pause mr-2"></i>暂停';
                gameConfig.lastTime = 0;
                gameConfig.deltaTime = 0;
                gameConfig.animationId = requestAnimationFrame(updateGame);
            }
        }
        
        // 重新开始游戏
        function restartGame() {
            // 停止当前游戏循环
            if (gameConfig.isRunning) {
                cancelAnimationFrame(gameConfig.animationId);
            }
            
            // 重置游戏状态
            gameConfig.isRunning = false;
            gameConfig.isPaused = false;
            gameConfig.speed = gameConfig.initialSpeed;
            
            // 更新按钮状态
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            pauseBtn.innerHTML = '<i class="fa fa-pause mr-2"></i>暂停';
            
            // 初始化游戏
            initGame();
        }
        
        // 游戏结束
        function gameOver() {
            // 停止游戏循环
            gameConfig.isRunning = false;
            cancelAnimationFrame(gameConfig.animationId);
            
            // 更新按钮状态
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            
            // 播放游戏结束音效
            if (gameConfig.soundEnabled) {
                gameConfig.soundEffects.gameOver.play();
            }
            
            // 更新游戏结束弹窗
            finalScoreElement.textContent = gameConfig.score;
            finalHighScoreElement.textContent = gameConfig.highScore;
            
            // 显示游戏结束弹窗
            gameOverModal.classList.remove('hidden');
        }
        
        // 切换声音
        function toggleSound() {
            gameConfig.soundEnabled = !gameConfig.soundEnabled;
            soundBtn.innerHTML = gameConfig.soundEnabled 
                ? '<i class="fa fa-volume-up mr-2"></i>声音' 
                : '<i class="fa fa-volume-off mr-2"></i>声音';
        }
        
        // 关闭游戏结束弹窗
        function closeGameOverModal() {
            gameOverModal.classList.add('hidden');
        }
        
        // 设置难度
        function setDifficulty(speed) {
            // 更新按钮状态
            difficultyBtns.forEach(btn => {
                if (btn.dataset.speed === speed.toString()) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // 更新游戏速度
            gameConfig.initialSpeed = speed;
            gameConfig.speed = speed;
        }
        
        // 处理键盘输入
        function handleKeydown(e) {
            // 阻止按键默认行为（防止页面滚动）
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // 方向控制
            switch (e.key) {
                case 'ArrowUp':
                    if (gameConfig.direction !== 'down') {
                        gameConfig.nextDirection = 'up';
                    }
                    break;
                case 'ArrowDown':
                    if (gameConfig.direction !== 'up') {
                        gameConfig.nextDirection = 'down';
                    }
                    break;
                case 'ArrowLeft':
                    if (gameConfig.direction !== 'right') {
                        gameConfig.nextDirection = 'left';
                    }
                    break;
                case 'ArrowRight':
                    if (gameConfig.direction !== 'left') {
                        gameConfig.nextDirection = 'right';
                    }
                    break;
                case ' ': // 空格键控制暂停/继续
                    if (gameConfig.isRunning) {
                        pauseGame();
                    } else {
                        startGame();
                    }
                    break;
                case 'r': // R键重新开始
                    restartGame();
                    break;
            }
        }
        
        // 窗口大小变化时重绘游戏
        function handleResize() {
            if (!gameConfig.isRunning) {
                initGame();
            }
        }
        
        // 初始化事件监听
        function initEventListeners() {
            // 键盘控制
            document.addEventListener('keydown', handleKeydown);
            
            // 按钮控制
            startBtn.addEventListener('click', startGame);
            pauseBtn.addEventListener('click', pauseGame);
            restartBtn.addEventListener('click', restartGame);
            soundBtn.addEventListener('click', toggleSound);
            playAgainBtn.addEventListener('click', () => {
                closeGameOverModal();
                restartGame();
                startGame();
            });
            closeModalBtn.addEventListener('click', closeGameOverModal);
            
            // 难度选择
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    setDifficulty(parseInt(btn.dataset.speed));
                    if (!gameConfig.isRunning) {
                        initGame();
                    }
                });
            });
            
            // 移动端控制
            mobileBtns.up.addEventListener('click', () => {
                if (gameConfig.direction !== 'down') {
                    gameConfig.nextDirection = 'up';
                }
            });
            mobileBtns.down.addEventListener('click', () => {
                if (gameConfig.direction !== 'up') {
                    gameConfig.nextDirection = 'down';
                }
            });
            mobileBtns.left.addEventListener('click', () => {
                if (gameConfig.direction !== 'right') {
                    gameConfig.nextDirection = 'left';
                }
            });
            mobileBtns.right.addEventListener('click', () => {
                if (gameConfig.direction !== 'left') {
                    gameConfig.nextDirection = 'right';
                }
            });
            
            // 窗口大小变化
            window.addEventListener('resize', handleResize);
            
            // 点击游戏结束弹窗背景关闭弹窗
            gameOverModal.addEventListener('click', (e) => {
                if (e.target === gameOverModal) {
                    closeGameOverModal();
                }
            });
        }
        
        // 加载本地存储的最高分
        function loadHighScore() {
            const highScore = localStorage.getItem('snakeHighScore');
            if (highScore) {
                gameConfig.highScore = parseInt(highScore);
                highScoreElement.textContent = gameConfig.highScore;
            }
        }
        
        // 初始化游戏
        function init() {
            loadHighScore();
            initEventListeners();
            initGame();
        }
        
        // 启动游戏
        window.onload = init;
    </script>

<!-- Author Signature Widget V2 -->
<script id="author-signature-widget-v2">
  (function() {
    function showSignature() {
      var authorNameStr = '马舶媛';

      if (document.getElementById('author-signature-container-v2')) {
        return;
      }

      var container = document.createElement('div');
      container.id = 'author-signature-container-v2';
      container.style.position = 'fixed';
      container.style.top = '50%';
      container.style.left = '50%';
      container.style.transform = 'translate(-50%, -50%) scale(0.7)';
      container.style.padding = '30px 50px';
      container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      container.style.color = 'white';
      container.style.borderRadius = '20px';
      container.style.zIndex = '2147483647';
      container.style.fontFamily = '"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif';
      container.style.fontSize = '10vw';
      container.style.fontWeight = 'bold';
      container.style.textAlign = 'center';
      container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
      container.style.opacity = '0';
      container.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      container.style.whiteSpace = 'nowrap';
      container.style.cursor = 'pointer';

      var textElement = document.createElement('span');
      textElement.textContent = '作者: ' + authorNameStr;

      var hideWidget = function() {
        container.style.transform = 'translate(-50%, -50%) scale(0.7)';
        container.style.opacity = '0';
        setTimeout(function() {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
        }, 500);
      };

      container.onclick = hideWidget;

      container.appendChild(textElement);
      document.body.appendChild(container);

      setTimeout(function() {
        container.style.opacity = '1';
        container.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 50);

      setTimeout(hideWidget, 5000);
    }

    if (document.body) {
        showSignature();
    } else {
        document.addEventListener('DOMContentLoaded', showSignature);
    }
  })();
</script>
</body>
</html>    