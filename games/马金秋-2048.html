<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#faf8ef',
                        secondary: '#bbada0',
                        cellEmpty: '#cdc1b4',
                        cell2: '#eee4da',
                        cell4: '#ede0c8',
                        cell8: '#f2b179',
                        cell16: '#f59563',
                        cell32: '#f67c5f',
                        cell64: '#f65e3b',
                        cell128: '#edcf72',
                        cell256: '#edcc61',
                        cell512: '#edc850',
                        cell1024: '#edc53f',
                        cell2048: '#edc22e',
                        textDark: '#776e65',
                        textLight: '#f9f6f2'
                    },
                    fontFamily: {
                        game: ['"Clear Sans"', 'Helvetica Neue', 'Arial', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .cell {
                @apply rounded-lg flex items-center justify-center font-bold transition-all duration-200 ease-in-out;
            }
            .game-grid {
                @apply bg-secondary rounded-xl p-3 grid grid-cols-4 gap-3;
            }
            .game-title {
                @apply text-[clamp(2rem,5vw,3rem)] font-bold text-textDark mb-2;
            }
            .game-score {
                @apply bg-secondary rounded-lg p-2 text-center min-w-[60px];
            }
            .score-title {
                @apply text-xs text-textLight font-bold uppercase;
            }
            .score-value {
                @apply text-xl font-bold text-white;
            }
            .game-btn {
                @apply bg-cell8 text-white font-bold py-2 px-4 rounded-lg hover:bg-cell16 transition-colors duration-200;
            }
            .game-overlay {
                @apply absolute inset-0 bg-black bg-opacity-50 rounded-xl flex items-center justify-center flex-col;
            }
            .game-message {
                @apply text-[clamp(1.5rem,4vw,2.5rem)] font-bold text-white mb-4;
            }
        }
    </style>
</head>
<body class="bg-primary min-h-screen flex flex-col items-center justify-center p-4 font-game">
<!-- 返回主页按钮 -->
<div id="homeNavigation" style="position: fixed; top: 20px; left: 20px; z-index: 9999;">
    <a href="../index.html" 
       style="display: inline-flex; align-items: center; gap: 8px; 
              background: linear-gradient(135deg, #FF6B6B, #4ECDC4); 
              color: white; padding: 12px 20px; border-radius: 25px; 
              text-decoration: none; font-family: 'Microsoft YaHei', sans-serif; 
              font-weight: bold; font-size: 14px; 
              box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);"
       onmouseover="this.style.transform='translateY(-2px) scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.3)';"
       onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.2)';">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        返回星球工坊
    </a>
</div>

    <div class="max-w-md w-full mx-auto">
        <div class="flex justify-between items-end mb-4">
            <div>
                <h1 class="game-title">2048</h1>
                <p class="text-textDark text-sm">Join the numbers and get to the <strong>2048</strong> tile!</p>
            </div>
            <div class="flex gap-2">
                <div class="game-score">
                    <div class="score-title">SCORE</div>
                    <div id="score" class="score-value">0</div>
                </div>
                <div class="game-score">
                    <div class="score-title">BEST</div>
                    <div id="best-score" class="score-value">0</div>
                </div>
            </div>
        </div>
        
        <button id="new-game" class="game-btn mb-6">
            <i class="fa fa-refresh mr-2"></i>New Game
        </button>
        
        <div class="relative">
            <div class="game-grid">
                <!-- Cells will be generated by JavaScript -->
            </div>
            <div id="game-overlay" class="game-overlay hidden">
                <div id="game-message" class="game-message"></div>
                <button id="play-again" class="game-btn">
                    <i class="fa fa-play mr-2"></i>Play Again
                </button>
            </div>
        </div>
        
        <div class="mt-6 text-textDark text-sm">
            <p><strong>How to play:</strong> Use your <span class="font-bold">arrow keys</span> to move the tiles. When two tiles with the same number touch, they <span class="font-bold">merge into one!</span></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game variables
            const gridSize = 4;
            let grid = [];
            let score = 0;
            let bestScore = localStorage.getItem('2048-best-score') || 0;
            let gameOver = false;
            let canMove = true;
            
            // DOM elements
            const gameGrid = document.querySelector('.game-grid');
            const scoreElement = document.getElementById('score');
            const bestScoreElement = document.getElementById('best-score');
            const newGameButton = document.getElementById('new-game');
            const playAgainButton = document.getElementById('play-again');
            const gameOverlay = document.getElementById('game-overlay');
            const gameMessage = document.getElementById('game-message');
            
            // Initialize best score display
            bestScoreElement.textContent = bestScore;
            
            // Initialize the game
            function initGame() {
                // Clear previous grid
                grid = [];
                gameGrid.innerHTML = '';
                score = 0;
                scoreElement.textContent = score;
                gameOver = false;
                gameOverlay.classList.add('hidden');
                canMove = true;
                
                // Create empty grid
                for (let row = 0; row < gridSize; row++) {
                    grid[row] = [];
                    for (let col = 0; col < gridSize; col++) {
                        grid[row][col] = 0;
                        
                        // Create cell element
                        const cell = document.createElement('div');
                        cell.id = `cell-${row}-${col}`;
                        cell.className = 'cell bg-cellEmpty text-2xl';
                        cell.dataset.value = '0';
                        gameGrid.appendChild(cell);
                    }
                }
                
                // Add initial two numbers
                addRandomNumber();
                addRandomNumber();
                updateGrid();
            }
            
            // Add a random number (2 or 4) to a random empty cell
            function addRandomNumber() {
                if (!hasEmptyCell()) return false;
                
                let emptyCells = [];
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (grid[row][col] === 0) {
                            emptyCells.push({ row, col });
                        }
                    }
                }
                
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                
                grid[randomCell.row][randomCell.col] = value;
                return true;
            }
            
            // Update the grid display
            function updateGrid() {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        const value = grid[row][col];
                        
                        // Update cell background and text color based on value
                        cell.className = getCellClass(value);
                        cell.dataset.value = value.toString();
                        
                        // Update cell text
                        if (value === 0) {
                            cell.textContent = '';
                        } else {
                            cell.textContent = value.toString();
                        }
                    }
                }
                
                // Update score display
                scoreElement.textContent = score;
                
                // Check if the game is over or won
                if (checkWin()) {
                    gameOver = true;
                    gameMessage.textContent = 'You Win!';
                    gameOverlay.classList.remove('hidden');
                } else if (!canMove && !hasEmptyCell() && !canMerge()) {
                    gameOver = true;
                    gameMessage.textContent = 'Game Over';
                    gameOverlay.classList.remove('hidden');
                }
            }
            
            // Get cell class based on value
            function getCellClass(value) {
                const classMap = {
                    0: 'cell bg-cellEmpty text-2xl',
                    2: 'cell bg-cell2 text-textDark text-2xl',
                    4: 'cell bg-cell4 text-textDark text-2xl',
                    8: 'cell bg-cell8 text-textLight text-2xl',
                    16: 'cell bg-cell16 text-textLight text-2xl',
                    32: 'cell bg-cell32 text-textLight text-2xl',
                    64: 'cell bg-cell64 text-textLight text-2xl',
                    128: 'cell bg-cell128 text-textLight text-xl',
                    256: 'cell bg-cell256 text-textLight text-xl',
                    512: 'cell bg-cell512 text-textLight text-xl',
                    1024: 'cell bg-cell1024 text-textLight text-sm',
                    2048: 'cell bg-cell2048 text-textLight text-sm',
                };
                
                // Handle values greater than 2048 with the same style
                if (value > 2048) {
                    return 'cell bg-cell2048 text-textLight text-xs';
                }
                
                return classMap[value] || 'cell bg-cellEmpty text-2xl';
            }
            
            // Check if there is an empty cell
            function hasEmptyCell() {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (grid[row][col] === 0) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Check if any cells can merge
            function canMerge() {
                // Check horizontal merges
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize - 1; col++) {
                        if (grid[row][col] === grid[row][col + 1]) {
                            return true;
                        }
                    }
                }
                
                // Check vertical merges
                for (let col = 0; col < gridSize; col++) {
                    for (let row = 0; row < gridSize - 1; row++) {
                        if (grid[row][col] === grid[row + 1][col]) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Check if the player has won
            function checkWin() {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        if (grid[row][col] >= 2048) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Handle keyboard input
            document.addEventListener('keydown', (event) => {
                if (gameOver || !canMove) return;
                
                let moved = false;
                
                // Clone grid to check if move is valid
                const previousGrid = JSON.parse(JSON.stringify(grid));
                
                switch (event.key) {
                    case 'ArrowUp':
                        moved = moveUp();
                        break;
                    case 'ArrowDown':
                        moved = moveDown();
                        break;
                    case 'ArrowLeft':
                        moved = moveLeft();
                        break;
                    case 'ArrowRight':
                        moved = moveRight();
                        break;
                    default:
                        return; // Ignore other keys
                }
                
                // Prevent page scrolling
                event.preventDefault();
                
                // If the grid changed, add a new number and update the grid
                if (moved) {
                    addRandomNumber();
                    updateGrid();
                    
                    // Update best score if needed
                    if (score > bestScore) {
                        bestScore = score;
                        bestScoreElement.textContent = bestScore;
                        localStorage.setItem('2048-best-score', bestScore);
                    }
                }
            });
            
            // Handle swipe events for mobile
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            
            document.addEventListener('touchstart', (event) => {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            }, { passive: true });
            
            document.addEventListener('touchend', (event) => {
                if (gameOver || !canMove) return;
                
                touchEndX = event.changedTouches[0].clientX;
                touchEndY = event.changedTouches[0].clientY;
                
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // Determine swipe direction based on which difference is greater
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Horizontal swipe
                    if (diffX > 30) {
                        moveRight();
                    } else if (diffX < -30) {
                        moveLeft();
                    }
                } else {
                    // Vertical swipe
                    if (diffY > 30) {
                        moveDown();
                    } else if (diffY < -30) {
                        moveUp();
                    }
                }
            }
            
            // Move functions
            function moveUp() {
                let moved = false;
                
                for (let col = 0; col < gridSize; col++) {
                    // Merge cells
                    for (let row = 1; row < gridSize; row++) {
                        if (grid[row][col] !== 0) {
                            let currentRow = row;
                            
                            // Move up until we hit a non-zero cell or the top
                            while (currentRow > 0 && grid[currentRow - 1][col] === 0) {
                                grid[currentRow - 1][col] = grid[currentRow][col];
                                grid[currentRow][col] = 0;
                                currentRow--;
                                moved = true;
                            }
                            
                            // Merge with the cell above if possible
                            if (currentRow > 0 && grid[currentRow - 1][col] === grid[currentRow][col]) {
                                grid[currentRow - 1][col] *= 2;
                                score += grid[currentRow - 1][col];
                                grid[currentRow][col] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            function moveDown() {
                let moved = false;
                
                for (let col = 0; col < gridSize; col++) {
                    // Merge cells
                    for (let row = gridSize - 2; row >= 0; row--) {
                        if (grid[row][col] !== 0) {
                            let currentRow = row;
                            
                            // Move down until we hit a non-zero cell or the bottom
                            while (currentRow < gridSize - 1 && grid[currentRow + 1][col] === 0) {
                                grid[currentRow + 1][col] = grid[currentRow][col];
                                grid[currentRow][col] = 0;
                                currentRow++;
                                moved = true;
                            }
                            
                            // Merge with the cell below if possible
                            if (currentRow < gridSize - 1 && grid[currentRow + 1][col] === grid[currentRow][col]) {
                                grid[currentRow + 1][col] *= 2;
                                score += grid[currentRow + 1][col];
                                grid[currentRow][col] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            function moveLeft() {
                let moved = false;
                
                for (let row = 0; row < gridSize; row++) {
                    // Merge cells
                    for (let col = 1; col < gridSize; col++) {
                        if (grid[row][col] !== 0) {
                            let currentCol = col;
                            
                            // Move left until we hit a non-zero cell or the left edge
                            while (currentCol > 0 && grid[row][currentCol - 1] === 0) {
                                grid[row][currentCol - 1] = grid[row][currentCol];
                                grid[row][currentCol] = 0;
                                currentCol--;
                                moved = true;
                            }
                            
                            // Merge with the cell to the left if possible
                            if (currentCol > 0 && grid[row][currentCol - 1] === grid[row][currentCol]) {
                                grid[row][currentCol - 1] *= 2;
                                score += grid[row][currentCol - 1];
                                grid[row][currentCol] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            function moveRight() {
                let moved = false;
                
                for (let row = 0; row < gridSize; row++) {
                    // Merge cells
                    for (let col = gridSize - 2; col >= 0; col--) {
                        if (grid[row][col] !== 0) {
                            let currentCol = col;
                            
                            // Move right until we hit a non-zero cell or the right edge
                            while (currentCol < gridSize - 1 && grid[row][currentCol + 1] === 0) {
                                grid[row][currentCol + 1] = grid[row][currentCol];
                                grid[row][currentCol] = 0;
                                currentCol++;
                                moved = true;
                            }
                            
                            // Merge with the cell to the right if possible
                            if (currentCol < gridSize - 1 && grid[row][currentCol + 1] === grid[row][currentCol]) {
                                grid[row][currentCol + 1] *= 2;
                                score += grid[row][currentCol + 1];
                                grid[row][currentCol] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            // Button event listeners
            newGameButton.addEventListener('click', initGame);
            playAgainButton.addEventListener('click', initGame);
            
            // Initialize the game
            initGame();
        });
    </script>

<!-- Author Signature Widget V2 -->
<script id="author-signature-widget-v2">
  (function() {
    function showSignature() {
      var authorNameStr = '*金秋';

      if (document.getElementById('author-signature-container-v2')) {
        return;
      }

      var container = document.createElement('div');
      container.id = 'author-signature-container-v2';
      container.style.position = 'fixed';
      container.style.top = '50%';
      container.style.left = '50%';
      container.style.transform = 'translate(-50%, -50%) scale(0.7)';
      container.style.padding = '30px 50px';
      container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      container.style.color = 'white';
      container.style.borderRadius = '20px';
      container.style.zIndex = '2147483647';
      container.style.fontFamily = '"PingFang SC", "Helvetica Neue", "Microsoft YaHei", sans-serif';
      container.style.fontSize = '10vw';
      container.style.fontWeight = 'bold';
      container.style.textAlign = 'center';
      container.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
      container.style.opacity = '0';
      container.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      container.style.whiteSpace = 'nowrap';
      container.style.cursor = 'pointer';

      var textElement = document.createElement('span');
      textElement.textContent = '作者: ' + authorNameStr;

      var hideWidget = function() {
        container.style.transform = 'translate(-50%, -50%) scale(0.7)';
        container.style.opacity = '0';
        setTimeout(function() {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
          }
        }, 500);
      };

      container.onclick = hideWidget;

      container.appendChild(textElement);
      document.body.appendChild(container);

      setTimeout(function() {
        container.style.opacity = '1';
        container.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 50);

      setTimeout(hideWidget, 5000);
    }

    if (document.body) {
        showSignature();
    } else {
        document.addEventListener('DOMContentLoaded', showSignature);
    }
  })();
</script>
</body>
</html>
    